"""
Code Generator for the C++ compiler.
Converts IR to target assembly code (x86-64).
"""

from typing import Dict, List, Optional, Set
import sys

sys.path.append('../..')

from src.ir.ir_instructions import *


class CodeGeneratorError(Exception):
    """Exception raised for code generation errors."""

    def __init__(self, message: str):
        self.message = message
        super().__init__(f"Code generation error: {message}")


class CodeGenerator:
    """
    Code generator for x86-64 assembly.

    Converts three-address code IR to x86-64 assembly language.
    """

    def __init__(self, target: str = "x86_64"):
        """
        Initialize code generator.

        Args:
            target: Target architecture (default: x86_64)
        """
        self.target = target
        self.output: List[str] = []
        self.label_map: Dict[str, str] = {}

        # Register allocation (simplified)
        self.var_locations: Dict[str, str] = {}  # variable -> location (register or stack)
        self.stack_offset = 0

        # Available registers (caller-saved and callee-saved)
        self.caller_saved = ['rax', 'rcx', 'rdx', 'rsi', 'rdi', 'r8', 'r9', 'r10', 'r11']
        self.callee_saved = ['rbx', 'r12', 'r13', 'r14', 'r15']
        self.available_regs = ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi']
        self.used_regs: Set[str] = set()

        # Calling convention (System V AMD64 ABI)
        self.param_regs = ['rdi', 'rsi', 'rdx', 'rcx', 'r8', 'r9']
        self.return_reg = 'rax'

    def generate(self, program: IRProgram) -> str:
        """
        Generate assembly code for the entire program.

        Args:
            program: IR program to compile

        Returns:
            Assembly code as a string
        """
        self.output = []

        # Assembly header
        self.emit_header()

        # Data section (global variables and string literals)
        if program.global_vars or program.string_literals:
            self.emit(".section .data")

            # Global variables
            for var in program.global_vars:
                self.emit(f"{var}:")
                self.emit("    .quad 0")

            # String literals
            for label, value in program.string_literals:
                self.emit(f"{label}:")
                self.emit(f'    .asciz {value}')

            self.emit("")

        # Text section (code)
        self.emit(".section .text")

        # Generate code for each function
        for func in program.functions:
            self.generate_function(func)

        return '\n'.join(self.output)

    def emit_header(self) -> None:
        """Emit assembly file header."""
        self.emit("# Generated by C++ Compiler")
        self.emit("# Target: x86-64")
        self.emit("")

    def generate_function(self, function: IRFunction) -> None:
        """Generate assembly for a function."""
        self.var_locations = {}
        self.stack_offset = 0
        self.used_regs = set()

        # Function label
        self.emit(f".globl {function.name}")
        self.emit(f"{function.name}:")

        # Function prologue
        self.emit_prologue(function)

        # Allocate stack space for local variables
        local_space = len(function.local_vars) * 8
        if local_space > 0:
            self.emit(f"    sub rsp, {local_space}")
            self.stack_offset = local_space

        # Map parameters to locations
        for i, param in enumerate(function.parameters):
            if i < len(self.param_regs):
                # Parameter in register
                stack_loc = -(i + 1) * 8
                self.var_locations[str(param)] = f"[rbp{stack_loc}]"
                self.emit(f"    mov QWORD PTR [rbp{stack_loc}], {self.param_regs[i]}")
            else:
                # Parameter on stack (from caller)
                stack_loc = (i - len(self.param_regs) + 2) * 8
                self.var_locations[str(param)] = f"[rbp+{stack_loc}]"

        # Map local variables to stack locations
        for i, var in enumerate(function.local_vars):
            offset = -(len(function.parameters) + i + 1) * 8
            self.var_locations[str(var)] = f"[rbp{offset}]"

        # Generate code for each instruction
        for instr in function.instructions:
            self.generate_instruction(instr)

        # Function epilogue (if not already emitted by return)
        self.emit_epilogue()

    def emit_prologue(self, function: IRFunction) -> None:
        """Emit function prologue."""
        self.emit("    push rbp")
        self.emit("    mov rbp, rsp")

    def emit_epilogue(self) -> None:
        """Emit function epilogue."""
        self.emit("    mov rsp, rbp")
        self.emit("    pop rbp")
        self.emit("    ret")
        self.emit("")

    def generate_instruction(self, instr: IRInstruction) -> None:
        """Generate assembly for a single IR instruction."""
        # Label
        if instr.opcode == IROpcode.LABEL:
            self.emit(f".{instr.label}:")
            return

        # Control flow
        if instr.opcode == IROpcode.GOTO:
            self.emit(f"    jmp .{instr.label}")
            return

        if instr.opcode == IROpcode.IF_FALSE:
            arg1_loc = self.get_location(instr.arg1)
            self.emit(f"    cmp {arg1_loc}, 0")
            self.emit(f"    je .{instr.label}")
            return

        if instr.opcode == IROpcode.IF_TRUE:
            arg1_loc = self.get_location(instr.arg1)
            self.emit(f"    cmp {arg1_loc}, 0")
            self.emit(f"    jne .{instr.label}")
            return

        # Return
        if instr.opcode == IROpcode.RETURN:
            if instr.arg1:
                arg1_loc = self.get_location(instr.arg1)
                self.emit(f"    mov rax, {arg1_loc}")
            self.emit_epilogue()
            return

        # Assignment
        if instr.opcode == IROpcode.ASSIGN:
            self.generate_assign(instr)
            return

        # Binary operations
        if instr.opcode in [IROpcode.ADD, IROpcode.SUB, IROpcode.MUL,
                            IROpcode.DIV, IROpcode.AND, IROpcode.OR, IROpcode.XOR]:
            self.generate_binary_op(instr)
            return

        # Comparison operations
        if instr.opcode in [IROpcode.EQ, IROpcode.NE, IROpcode.LT,
                            IROpcode.LE, IROpcode.GT, IROpcode.GE]:
            self.generate_comparison(instr)
            return

        # Unary operations
        if instr.opcode in [IROpcode.NEG, IROpcode.NOT, IROpcode.LNOT]:
            self.generate_unary_op(instr)
            return

        # Function call
        if instr.opcode == IROpcode.PARAM:
            # Parameters are handled in CALL
            return

        if instr.opcode == IROpcode.CALL:
            self.generate_call(instr)
            return

        # Memory operations
        if instr.opcode == IROpcode.LOAD:
            self.generate_load(instr)
            return

        if instr.opcode == IROpcode.STORE:
            self.generate_store(instr)
            return

        # Array operations
        if instr.opcode == IROpcode.INDEX:
            self.generate_index(instr)
            return

        # Default: emit as comment
        self.emit(f"    # {instr}")

    def generate_assign(self, instr: IRInstruction) -> None:
        """Generate assignment: result = arg1"""
        result_loc = self.allocate_location(instr.result)
        arg1_loc = self.get_location(instr.arg1)

        if isinstance(instr.arg1, IRConstant):
            self.emit(f"    mov {result_loc}, {arg1_loc}")
        else:
            self.emit(f"    mov rax, {arg1_loc}")
            self.emit(f"    mov {result_loc}, rax")

    def generate_binary_op(self, instr: IRInstruction) -> None:
        """Generate binary operation: result = arg1 op arg2"""
        result_loc = self.allocate_location(instr.result)
        arg1_loc = self.get_location(instr.arg1)
        arg2_loc = self.get_location(instr.arg2)

        # Load arg1 into rax
        self.emit(f"    mov rax, {arg1_loc}")

        # Perform operation
        if instr.opcode == IROpcode.ADD:
            self.emit(f"    add rax, {arg2_loc}")
        elif instr.opcode == IROpcode.SUB:
            self.emit(f"    sub rax, {arg2_loc}")
        elif instr.opcode == IROpcode.MUL:
            self.emit(f"    imul rax, {arg2_loc}")
        elif instr.opcode == IROpcode.DIV:
            self.emit(f"    mov rbx, {arg2_loc}")
            self.emit(f"    cqo")  # Sign extend rax to rdx:rax
            self.emit(f"    idiv rbx")
        elif instr.opcode == IROpcode.AND:
            self.emit(f"    and rax, {arg2_loc}")
        elif instr.opcode == IROpcode.OR:
            self.emit(f"    or rax, {arg2_loc}")
        elif instr.opcode == IROpcode.XOR:
            self.emit(f"    xor rax, {arg2_loc}")

        # Store result
        self.emit(f"    mov {result_loc}, rax")

    def generate_comparison(self, instr: IRInstruction) -> None:
        """Generate comparison: result = arg1 cmp arg2"""
        result_loc = self.allocate_location(instr.result)
        arg1_loc = self.get_location(instr.arg1)
        arg2_loc = self.get_location(instr.arg2)

        # Compare
        self.emit(f"    mov rax, {arg1_loc}")
        self.emit(f"    cmp rax, {arg2_loc}")

        # Set result based on comparison
        cmp_map = {
            IROpcode.EQ: 'sete',
            IROpcode.NE: 'setne',
            IROpcode.LT: 'setl',
            IROpcode.LE: 'setle',
            IROpcode.GT: 'setg',
            IROpcode.GE: 'setge',
        }

        set_instr = cmp_map[instr.opcode]
        self.emit(f"    {set_instr} al")
        self.emit(f"    movzx rax, al")
        self.emit(f"    mov {result_loc}, rax")

    def generate_unary_op(self, instr: IRInstruction) -> None:
        """Generate unary operation: result = op arg1"""
        result_loc = self.allocate_location(instr.result)
        arg1_loc = self.get_location(instr.arg1)

        self.emit(f"    mov rax, {arg1_loc}")

        if instr.opcode == IROpcode.NEG:
            self.emit(f"    neg rax")
        elif instr.opcode == IROpcode.NOT:
            self.emit(f"    not rax")
        elif instr.opcode == IROpcode.LNOT:
            self.emit(f"    cmp rax, 0")
            self.emit(f"    sete al")
            self.emit(f"    movzx rax, al")

        self.emit(f"    mov {result_loc}, rax")

    def generate_call(self, instr: IRInstruction) -> None:
        """Generate function call."""
        func_name = str(instr.arg1)
        num_args = instr.arg2.value if isinstance(instr.arg2, IRConstant) else 0

        # For simplicity, assume arguments are already in parameter registers
        # Full implementation would need to track and move parameters

        self.emit(f"    call {func_name}")

        # Store return value if needed
        if instr.result:
            result_loc = self.allocate_location(instr.result)
            self.emit(f"    mov {result_loc}, rax")

    def generate_load(self, instr: IRInstruction) -> None:
        """Generate load: result = *arg1"""
        result_loc = self.allocate_location(instr.result)
        arg1_loc = self.get_location(instr.arg1)

        self.emit(f"    mov rax, {arg1_loc}")
        self.emit(f"    mov rax, [rax]")
        self.emit(f"    mov {result_loc}, rax")

    def generate_store(self, instr: IRInstruction) -> None:
        """Generate store: *result = arg1"""
        result_loc = self.get_location(instr.result)
        arg1_loc = self.get_location(instr.arg1)

        self.emit(f"    mov rax, {result_loc}")
        self.emit(f"    mov rbx, {arg1_loc}")
        self.emit(f"    mov [rax], rbx")

    def generate_index(self, instr: IRInstruction) -> None:
        """Generate array indexing: result = arg1[arg2]"""
        result_loc = self.allocate_location(instr.result)
        array_loc = self.get_location(instr.arg1)
        index_loc = self.get_location(instr.arg2)

        # Calculate address: base + index * 8
        self.emit(f"    mov rax, {array_loc}")
        self.emit(f"    mov rbx, {index_loc}")
        self.emit(f"    imul rbx, 8")
        self.emit(f"    add rax, rbx")
        self.emit(f"    mov rax, [rax]")
        self.emit(f"    mov {result_loc}, rax")

    def get_location(self, value: IRValue) -> str:
        """Get the assembly location for an IR value."""
        if isinstance(value, IRConstant):
            return str(value.value)

        if isinstance(value, (IRTemp, IRVariable)):
            var_name = str(value)
            if var_name in self.var_locations:
                return self.var_locations[var_name]
            else:
                # Allocate new location
                return self.allocate_location(value)

        if isinstance(value, IRLabel):
            return str(value)

        return str(value)

    def allocate_location(self, value: IRValue) -> str:
        """Allocate a location (register or stack) for a value."""
        var_name = str(value)

        if var_name in self.var_locations:
            return self.var_locations[var_name]

        # Allocate on stack
        self.stack_offset += 8
        location = f"[rbp-{self.stack_offset}]"
        self.var_locations[var_name] = location

        return location

    def emit(self, line: str) -> None:
        """Emit a line of assembly code."""
        self.output.append(line)